package queries

import "http://inf.mit.bme.hu/testcase"

@Constraint(severity = "error",
            message = "The 'toLane reference of the lane points to itself",
            key = {lane})
pattern leadsToItself(lane: Lane) {
	Lane.toLane(lane, lane);
}

@Constraint(severity = "error",
            message = "The 'rightLane' reference of the roadcomponent points to itself",
            key = {comp})
pattern nextToItself(comp: RoadComponent) {
	RoadComponent.rightLane(comp, comp);
}

@Constraint(severity = "error",
            message = "There is a cycle of 'righLane' references",
            key = {lane})
pattern nextToCycle(lane: RoadComponent) {
	find rightLane+(lane,lane);
}

pattern rightLane(l1: RoadComponent, l2: RoadComponent){
	RoadComponent.rightLane(l1, l2);
}

pattern leftLane(l1: RoadComponent, l2: RoadComponent){
	RoadComponent.leftLane(l1, l2);
}

@Constraint(severity = "error",
            message = "A parallel pair of lanes cross while connecting to an other parallel pair of lanes",
            key = {lane1, lane2})
pattern crossConnection(lane1: Lane, lane2: Lane, lane3: Lane, lane4: Lane) {
	//RoadComponent.rightLane(lane1, lane2);
	//RoadComponent.rightLane(lane3, lane4);
	find rightLane+(lane1, lane2);
	find rightLane+(lane4, lane3);
	Lane.toLane(lane1, lane3);
	Lane.toLane(lane2, lane4);
}

@Constraint(severity = "error",
            message = "Lane is next to a lane, that is in a different segment or other direction",
            key = {lane1, lane2})
pattern laneInWrongSegment(lane1: RoadComponent, lane2: RoadComponent) {
	RoadComponent.leftLane(lane1, lane2);
	neg find lanesInSameSegmentAndDirection(_segm, lane1, lane2);
}

pattern lanesInSameSegmentAndDirection(seg: RoadSegment, l1: RoadComponent, l2: RoadComponent) {
	l1 != l2;
	RoadSegment.forward(seg, l1);
	RoadSegment.forward(seg, l2);
} or {
	l1 != l2;
	RoadSegment.backward(seg, l1);
	RoadSegment.backward(seg, l2);
	
}

pattern lanesInSameSegmentOpoositeDirection(seg: RoadSegment, l1: RoadComponent, l2: RoadComponent) {
	l1 != l2;
	RoadSegment.forward(seg, l1);
	RoadSegment.backward(seg, l2);
} or {
	l1 != l2;
	RoadSegment.backward(seg, l1);
	RoadSegment.forward(seg, l2);
	
}

pattern reachableTroughRightLane(l1: RoadComponent, l2: RoadComponent) {
	find rightLane+(l1, l2);
}

pattern segmentHasUnconnectedLanesInSameDirection(segm: RoadSegment) {
	lane1 != lane2;
	find lanesInSameSegmentAndDirection(segm, lane1, lane2);
	neg find reachableTroughRightLane(lane1, lane2);
	neg find reachableTroughRightLane(lane2, lane1);
}

pattern lanesLeftOfToEachOther(lane1: RoadComponent, lane2: RoadComponent) {
	RoadComponent.left(lane1, lane2);
	RoadComponent.left(lane2, lane1);
}

@Constraint(severity = "error",
            message = "The leftmost lanes of the two directions are not to the 'left' of each other",
            key = {lane1, lane2})
pattern oppositeLanesNotNextToEachOther(segm: RoadSegment, lane1: RoadComponent, lane2: RoadComponent) {
	find lanesInSameSegmentOpoositeDirection(segm, lane1, lane2);
	neg find segmentHasUnconnectedLanesInSameDirection(segm);
	neg find lanesLeftOfToEachOther(lane1, lane2);
}

@Constraint(severity = "error",
            message = "Not leftmost lane of a direction has a 'left' reference",
            key = {lane})
pattern notLeftmostLaneNextToOtherDirection(lane: Lane) {
	find leftLane(lane, _l2);
	RoadComponent.left(lane, _l3);
}

// If they turn in the opposite direction, I can't draw them (atm).
// If it's important, it can be done.
@Constraint(severity = "error",
            message = "Turn is following an other turn",
            key = {turn2})
pattern turnFollowingTurn(turn1: Lane, turn2: Lane) {
	Lane.straight(turn1, false);
	Lane.straight(turn2, false);
	Lane.toLane(turn1, turn2);
}